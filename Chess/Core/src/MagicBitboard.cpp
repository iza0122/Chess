#include "MagicBitboard.h"
#include "Bitboard.h"
#include <random>

vector2D bishopDirection[4] = {
    {1,1},
    {-1,1},
    {1,-1},
    {-1,-1}
};


/**
 * @brief Generates the blocker mask for a rook on a given square.
 *
 * This function computes a bitboard mask representing all squares that could potentially block
 * a rook's movement from the specified index on a standard 8x8 chessboard. The mask excludes
 * edge squares, considering only the squares between the rook and the edge in each direction.
 *
 * @param index The square index (0-63) where the rook is located.
 * @return u64 Bitboard mask of potential blocker squares for the rook.
 */
u64 rookBlockerMask(ui index)
{
    u64 blockerMask = C64(0);
    int row = index / 8;
    int col = index % 8;
    for (int i = 1; i < 7 - row; i++){
        setBit(blockerMask, index + i * 8);
    }
    for (int i = row - 1; i > 0; i--){
        setBit(blockerMask, index - i * 8);
    }
    for (int i = 1; i < 7 - col; i++){
        setBit(blockerMask, index + i);
    }
    for (int i = col - 1; i > 0; i--){
        setBit(blockerMask, index - i);
    }
    return blockerMask;
}

/**
 * @brief Generates all possible blocker board combinations from a given blocker mask.
 *
 * Given a bitboard mask representing blocker squares, this function computes all possible
 * subsets of blockers (as bitboards) that can be formed from the set bits in the mask.
 * Each subset corresponds to a possible arrangement of blockers on the specified squares.
 *
 * @param blockerMask A 64-bit unsigned integer representing the blocker mask (bitboard).
 * @return std::vector<u64> A vector containing all possible blocker bitboards derived from the mask.
 */
std::vector<u64> blockerBoard(const u64 &blockerMask)
{
    std::vector<int> squares;
    std::vector<u64> result;
    for (int sq = 0; sq < 64; sq++) {
        if (blockerMask & (1ULL << sq)) squares.push_back(sq);
    }
    int n = squares.size();
    int subsets = 1 << n;
    for (int index = 0; index < subsets; index++) {
        u64 blockers = 0ULL;
        for (int i = 0; i < n; i++) {
            if (index & (1 << i)) {
                blockers |= (1ULL << squares[i]);
            }
        }
        result.push_back(blockers);
    }
    return result;
}

/**
 * @brief Generates the blocker mask for a bishop on a given square.
 *
 * This function calculates the mask representing all squares that could block
 * the movement of a bishop from the specified index on a chessboard. The mask
 * excludes edge squares and only includes squares between the bishop and the edge
 * in all four diagonal directions.
 *
 * @param index The square index (0-63) for which to generate the blocker mask.
 * @return u64 The blocker mask as a 64-bit unsigned integer.
 */
u64 bishopBlockerMask(ui index)
{
    u64 blockerMask = C64(0);
    vector2D currentPosition(index % 8, index / 8);
    for (int i = 1; i < 7; i++){
        for (int j = 0; j < 4; j++){
            vector2D updatedDirection(bishopDirection[j].x * i, bishopDirection[j].y * i);
            vector2D sum = currentPosition + updatedDirection;
            if (sum.x > 0 && sum.y > 0 && sum.x < 7 && sum.y < 7){
                setBit(blockerMask, sum.x + 8*sum.y);
            }
        }
    }
    return blockerMask;
}


/**
 * @brief Generates a random 64-bit unsigned integer.
 *
 * This function combines four 16-bit random values generated by `rand()`
 * to produce a single 64-bit unsigned integer. Each call to `rand()` is masked
 * to 16 bits and then shifted to its appropriate position within the 64-bit result.
 *
 * @return A randomly generated 64-bit unsigned integer.
 */
uint64_t random_uint64() {
  uint64_t u1, u2, u3, u4;
  u1 = (uint64_t)(rand()) & 0xFFFF; u2 = (uint64_t)(rand()) & 0xFFFF;
  u3 = (uint64_t)(rand()) & 0xFFFF; u4 = (uint64_t)(rand()) & 0xFFFF;
  return u1 | (u2 << 16) | (u3 << 32) | (u4 << 48);
}


/**
 * @brief Generates a random 64-bit unsigned integer with relatively few bits set.
 *
 * This function combines the results of three calls to random_uint64() using bitwise AND,
 * resulting in a number with fewer bits set than a single random_uint64() call.
 * Useful for generating sparse bitboards or random masks with low density.
 *
 * @return uint64_t A random 64-bit unsigned integer with few bits set.
 */
uint64_t random_uint64_fewbits() {
  return random_uint64() & random_uint64() & random_uint64();
}

/**
 * @brief Finds a suitable magic number for rook move generation using magic bitboards.
 *
 * This function attempts to find a magic number for a given square that can be used to
 * efficiently index rook attack patterns in a magic bitboard implementation. It generates
 * random candidate magic numbers and tests them against all possible blocker configurations
 * for the square, ensuring that each configuration maps to a unique index in the attack table.
 *
 * @param square The board square (0-63) for which to find the magic number.
 * @return A 64-bit unsigned integer representing the found magic number.
 */
u64 findRookMagic(ui square){
    u64 magic = random_uint64_fewbits();
    int size = 1ULL << (64 - rookShift[square]);
    std::vector<u64> rookAttack(size, 0);
    std::vector<u64> occupancy = blockerBoard(rookMask[square]);
    int i = 0;
    while(true){
        if (i == size) break;
        u64 index = ((occupancy[i] * magic) >> rookShift[square]);
        if(rookAttack[index] != 0){
            std::fill(rookAttack.begin(), rookAttack.end(), 0);
            magic = random_uint64_fewbits();
            i = 0;
            continue;
        }
        rookAttack[index] = 1;
        i++;
    }
    return magic;
}

/**
 * @brief Finds a suitable magic number for bishop move generation on a given square.
 *
 * This function attempts to find a magic number that can be used to efficiently
 * index bishop attack patterns using bitboards. It generates random magic numbers
 * and tests them against all possible blocker configurations for the specified square,
 * ensuring that each configuration maps to a unique index in the attack table.
 *
 * @param square The board square (0-63) for which to find the bishop magic number.
 * @return A 64-bit unsigned integer representing the found magic number.
 */
u64 findBishopMagic(ui square){
    u64 magic = random_uint64_fewbits();
    int size = 1ULL << (64 - bishopShift[square]);
    std::vector<u64> bishopAttack(size, 0);
    std::vector<u64> occupancy = blockerBoard(bishopMask[square]);
    int i = 0;
    while(true){
        if (i == size) break;
        u64 index = ((occupancy[i] * magic) >> bishopShift[square]);
        if(bishopAttack[index] != 0){
            std::fill(bishopAttack.begin(), bishopAttack.end(), 0);
            magic = random_uint64_fewbits();
            i = 0;
            continue;
        }
        bishopAttack[index] = 1;
        i++;
    }
    return magic;
}

/**
 * @brief Returns the attack bitboard for a rook on a given square with a given occupancy.
 *
 * This function calculates all squares a rook can attack from the specified square,
 * considering the current occupancy bitboard. The rook's movement is blocked by any
 * piece encountered in each direction.
 *
 * @param square The board square (0-63) where the rook is located.
 * @param occupancy The occupancy bitboard representing blocked squares.
 * @return u64 Bitboard of all squares attacked by the rook.
 */
u64 getRookAttack(int square, u64 occupancy) {
    u64 attacks = 0ULL;
    int rank = square / 8;
    int file = square % 8;

    // Move north
    for (int r = rank + 1; r <= 7; r++) {
        int sq = r * 8 + file;
        attacks |= (1ULL << sq);
        if (occupancy & (1ULL << sq)) break;
    }

    // Move south
    for (int r = rank - 1; r >= 0; r--) {
        int sq = r * 8 + file;
        attacks |= (1ULL << sq);
        if (occupancy & (1ULL << sq)) break;
    }

    // Move east
    for (int f = file + 1; f <= 7; f++) {
        int sq = rank * 8 + f;
        attacks |= (1ULL << sq);
        if (occupancy & (1ULL << sq)) break;
    }

    // Move west
    for (int f = file - 1; f >= 0; f--) {
        int sq = rank * 8 + f;
        attacks |= (1ULL << sq);
        if (occupancy & (1ULL << sq)) break;
    }

    return attacks;
}

/**
 * @brief Returns the attack bitboard for a bishop on a given square with a given occupancy.
 *
 * This function calculates all squares a bishop can attack from the specified square,
 * considering the current occupancy bitboard. The bishop's movement is blocked by any
 * piece encountered in each diagonal direction.
 *
 * @param square The board square (0-63) where the bishop is located.
 * @param occupancy The occupancy bitboard representing blocked squares.
 * @return u64 Bitboard of all squares attacked by the bishop.
 */
u64 getBishopAttack(int square, u64 occupancy) {
    u64 attacks = 0ULL;
    int rank = square / 8;
    int file = square % 8;

    // Diagonal northeast (NE)
    for (int r = rank + 1, f = file + 1; r <= 7 && f <= 7; r++, f++) {
        int sq = r * 8 + f;
        attacks |= (1ULL << sq);
        if (occupancy & (1ULL << sq)) break;
    }

    // Diagonal northwest (NW)
    for (int r = rank + 1, f = file - 1; r <= 7 && f >= 0; r++, f--) {
        int sq = r * 8 + f;
        attacks |= (1ULL << sq);
        if (occupancy & (1ULL << sq)) break;
    }

    // Diagonal southeast (SE)
    for (int r = rank - 1, f = file + 1; r >= 0 && f <= 7; r--, f++) {
        int sq = r * 8 + f;
        attacks |= (1ULL << sq);
        if (occupancy & (1ULL << sq)) break;
    }

    // Diagonal southwest (SW)
    for (int r = rank - 1, f = file - 1; r >= 0 && f >= 0; r--, f--) {
        int sq = r * 8 + f;
        attacks |= (1ULL << sq);
        if (occupancy & (1ULL << sq)) break;
    }

    return attacks;
}

/**
 * @brief Generates a list of possible rook attack bitboards for a given square.
 * 
 * This function calculates all possible attack bitboards for a rook placed on the specified square.
 * and maps to its respective magic index
 * 
 * @param square The square index (0-63) representing the position of the rook on the chessboard.
 * @return A vector of 64-bit unsigned integers (u64), where each element represents a possible attack bitboard
 *         for the rook on the given square.
 */
const std::vector<u64> rookAttackList(ui square) {
    u64 rookBlocker = rookBlockerMask(square);
    std::vector<u64> rookOccupancy = blockerBoard(rookBlocker);
    int size = rookOccupancy.size();
    std::vector<u64> result(size);
    for (int i = 0; i < size; i++){
        int index = (rookOccupancy[i] * rookMagic[square]) >> rookShift[square];
        result[index] = getRookAttack(square, rookOccupancy[i]);
    }
    return result;
}

/**
 * @brief Generates a list of bishop attack bitboards for a given square.
 *
 * This function calculates all possible attack bitboards for a bishop
 * placed on the specified square and maps to its respective magic index.
 *
 * @param square The square index (0-63) representing the position of the bishop on the chessboard.
 * @return A vector of 64-bit unsigned integers (u64), where each element represents
 *         a possible attack bitboard for the bishop on the given square.
 */
const std::vector<u64> bishopAttackList(ui square) {
    u64 bishopBlocker = bishopBlockerMask(square);
    std::vector<u64> bishopOccupancy = blockerBoard(bishopBlocker);
    int size = bishopOccupancy.size();
    std::vector<u64> result(size);
    for (int i = 0; i < size; i++){
        int index = (bishopOccupancy[i] * bishopMagic[square]) >> bishopShift[square];
        result[index] = getBishopAttack(square, bishopOccupancy[i]);
    }
    return result;
}

/**
 * @brief Generates a table of precomputed attack bitboards for a rook on each square of the chessboard.
 * 
 * This function creates a 2D vector where each row corresponds to a square on the chessboard (0-63),
 * and each element in the row represents a possible attack bitboard for a rook on that square.
 * 
 * @return A 2D vector of 64 rows, where each row contains the precomputed attack bitboards for a rook.
 */
const std::vector<std::vector<u64>> rookAttackTable() {
    std::vector<std::vector<u64>> result;
    for (int i = 0; i < 64; i++) {
        result.push_back(rookAttackList(i));
    }
    return result;
}

/**
 * @brief Generates a table of precomputed attack bitboards for a bishop on each square of the chessboard.
 * 
 * This function creates a 2D vector where each row corresponds to a square on the chessboard (0-63),
 * and each element in the row represents a possible attack bitboard for a bishop on that square.
 * 
 * @return A 2D vector of 64 rows, where each row contains the precomputed attack bitboards for a bishop.
 */
const std::vector<std::vector<u64>> bishopAttackTable() {
    std::vector<std::vector<u64>> result;
    for (int i = 0; i < 64; i++) {
        result.push_back(bishopAttackList(i));
    }
    return result;
}
